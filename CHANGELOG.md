# Анализатор качества репозиториев

## 0.9.1 (29.09.2024)

* https://github.com/isas2/rails-project-66/blob/f3f466fdf69d4a9f3375f6a40d7a29f0000b236b/CHANGELOG.md?plain=1#L7 - ререндер быстрее. Плюс он автомагически отобразит ошибки в форме

* https://github.com/isas2/rails-project-66/blob/f3f466fdf69d4a9f3375f6a40d7a29f0000b236b/CHANGELOG.md?plain=1#L12 - да, но я имела в виду хелпер, который живёт в папке helpers и используется только для вьюх.

* https://github.com/isas2/rails-project-66/blob/f3f466fdf69d4a9f3375f6a40d7a29f0000b236b/CHANGELOG.md?plain=1#L16 - вполне валидный пойнт и хорошо реализованное решение. Единственное, что я бы в нём улучшила - в offences собирала бы не массив, а хэш с ключами, имена которых говорят о том, что под ними хранится

  - Сделано

* https://github.com/isas2/rails-project-66/blob/f3f466fdf69d4a9f3375f6a40d7a29f0000b236b/CHANGELOG.md?plain=1#L21 - ну вот это как раз не очень хорошо, так мы размазали логику стаббинга. Можно в стабе ориентироваться на саму команду и по ключевым словам в ней выдавать результат

  - Вынес в отдельный массив в сам стаб 

* https://github.com/isas2/rails-project-66/blob/f3f466fdf69d4a9f3375f6a40d7a29f0000b236b/CHANGELOG.md?plain=1#L25 - у меня проблема воспроизвелась сразу же, я проверяла на втором своём юзвере в гитхабе. Он увидел в селекте репы первого

* https://github.com/isas2/rails-project-66/blob/f3f466fdf69d4a9f3375f6a40d7a29f0000b236b/CHANGELOG.md?plain=1#L41 - в остальные тесты тоже хорошо бы добавить проверки по результатам работы джоб

## 0.9.0 (23.09.2024)

* https://github.com/isas2/rails-project-66/blob/ba0362e5f5d39e347cd0a513fce0532ea7ae1aee/app/controllers/web/repositories_controller.rb#L26 - а зачем редирект, если можно обойтись render?

  - На лекциях разницу и особенности не объясняли
  - Без 'status: :unprocessable_entity' не отображались алерты. https://dev.to/rbazinet/how-to-fix-rails-flash-rendering-when-using-hotwire-3o56

* https://github.com/isas2/rails-project-66/blob/ba0362e5f5d39e347cd0a513fce0532ea7ae1aee/app/views/web/repositories/checks/show.html.slim#L37 - явно просится в хелпер, тем более, что используешь не в одном месте. Со ссылкой на файл та же история

  - Сделано

* https://github.com/isas2/rails-project-66/blob/ba0362e5f5d39e347cd0a513fce0532ea7ae1aee/app/views/web/repositories/checks/show.html.slim#L58 - такой сложной логике точно не место во вьюхе. Уже сейчас сложно, при добавлении других языков и линтеров будет кошмар. Форматирование данных должно происходить до того, как они попадут во вьюху, её задача их просто отрендерить. Опять же, форматировать их можно один раз, перед сохранением в БД

  - "форматировать ... перед сохранением в БД": Тут сработало правило, что когда не указано, какие данные нужно сохраненять для будущего, то сохраняем все. Если завтра юзер захочет новый формат и полный отчёт, а исходных данных уже нет? Самый дешевый ресурс - хранилище (если правильно хранить конечно).
  - Вынес обработку в helper, теперь вьюха ничего не знает о языках.

* https://github.com/isas2/rails-project-66/blob/ba0362e5f5d39e347cd0a513fce0532ea7ae1aee/app/lib/command_helper.rb - классную обёртку написал! Проблема только со стабом для неё - в тестах в RepositoryCloneJob в commit_id ты будешь писать '{"summary":{"offense_count":0}}'. Стаб должен ориентироваться на переданную команду и возвращать релевантный ответ

  - Сделал очень релевантный ответ, вот только не знаю насколько это корректно, чтобы класс сам заботился о работе своего стаба.

* https://github.com/isas2/rails-project-66/blob/ba0362e5f5d39e347cd0a513fce0532ea7ae1aee/app/lib/github_helper.rb#L17 - круто, что закэшировал, но было бы неплохо учесть айдишник пользователя в кэше, иначе все будут видеть одно и то же.

  - Это первое о чём я подумал, когда добавлял кеширование. Поэтому проверял на несколько раз двумя пользователями в одном и в разных браузерах, чтения чужого кеша не было. К сожалению, не смог получить список ключей в кеше, метод из лекции не сработал.
  - Добавил ID пользователя, так правильнее

* https://github.com/isas2/rails-project-66/blob/ba0362e5f5d39e347cd0a513fce0532ea7ae1aee/app/lib/github_helper.rb#L3 - в RepositoryUpdateJob ты вызываешь последовательно repo_info и new_repo_hook, таким образом дважды инициализируешь Octokit::Client. Можно добавить initialize в GithubHelper и делать это там

  - Первоначально так и было, убрал в последнем коммите.
  - Вернул

* https://github.com/isas2/rails-project-66/blob/ba0362e5f5d39e347cd0a513fce0532ea7ae1aee/app/jobs/repository_update_job.rb#L7 - хорошей практикой в джобах является обработка кейса, когда find_by вернул nil (обычно просто return). В этом приложении мы пока не можем удалять сущности, так что это не очень актуально.

* "При переводе чека в fail, временный каталог очищается. Т.е. нужно просто запустить ещё раз, проверил, там пусто." - да, но предыдущие проверки зависли в статусе cloning. Для пользователя очень непонятно, что делать в такой ситуации. Если в RepositoryCloneJob и RepositoryCheckJob добавить rescue StandardError с переводом проверки в failed статус и очисткой папки - всё станет удобнее и понятнее.

  - При получении кода ошибки из выполняемой команды, check переходит в failed и пользователь видит сообщение об ошибке;
  - Что привело к "зависли в статусе cloning"? Лучший вариант - воспроизвести ошибку и исправить, но уже не воспроизводится;
  - Добавил обработчик, захватил пока пошире, т.к. точное место ошибки неизвестно.

* https://github.com/isas2/rails-project-66/blob/ba0362e5f5d39e347cd0a513fce0532ea7ae1aee/test/controllers/web/repositories_controller_test.rb#L28 - здесь, как и в остальных тестах, хорошо бы проверить и результат работы джобы, которая запускается в экшне. У тебя это есть только в Api::ChecksControllerTest. Проще всего добавить в test_helper

  ```
  class ActiveSupport::TestCase
    setup do
      queue_adapter.perform_enqueued_jobs = true
      queue_adapter.perform_enqueued_at_jobs = true
    end
  end
  ```
  - Тогда джобы будут выполняться всегда в тестах
  - Добавил

* https://github.com/isas2/rails-project-66/blob/ba0362e5f5d39e347cd0a513fce0532ea7ae1aee/CHANGELOG.md?plain=1#L29 - это если повезло и апишка ничем не нагружена. Но рассчитывать мы на это не можем, поэтому такие вещи и стараются по максимуму уносить в асинхронщину. Насчёт ajax - ну да, на фронте есть варианты, как это решить, но это всё-таки курс не по js

* https://github.com/isas2/rails-project-66/blob/ba0362e5f5d39e347cd0a513fce0532ea7ae1aee/CHANGELOG.md?plain=1#L44 - проблема в том, что check зависает в каком-то стейте. Описала уже в комменте выше


## 0.8.0 (19.09.2024)

* Главную сайта классно оформил, мне нравится!

  - Спасибо!

* Папку .idea хорошо бы дропнуть и после этого отправить в гитигнор - это всё-таки локальные настройки твоей IDE

  - Спрятал, у меня Rubymine тестовый

Как обычно, код не смотрела особо на первой проверке, давай разбираться с функционалом

* https://ror.zabedu.ru/repositories/7/checks/19 - проверка рубишной репы падает с ошибкой. Проблема в том, что ты используешь конфиг рубокопа из проверяемой репы, а нужно - из твоего приложения. Смысл же в том, чтобы проверять все репы пользователей по одному конфигу, даже если у них в репах вообще нет рубокопа. То же самое касается eslint

  - Добавил пути до конфигов

* https://ror.zabedu.ru/repositories/8 - проверка js-ной репы зависла на стадии клонирования

  - Не совсем понял на чём запнулось, сделал себе клон этой репы, вроде всё проходит

* Тесты падают на том, что не могу найти созданную репу с переданным github_id. Вот здесь https://github.com/isas2/rails-project-66/blob/main/app/controllers/web/repositories_controller.rb#L21 в тестах берётся стаб из фикстур, там хардкод для github_id. Получается, что ты игнорируешь github_id из параметров и всегда подставляешь тот, что в фикстурах.

  - Исправлено

* Что ещё - ходить за данными репозитория хорошо бы асинхронно, а не заставлять пользователя ждать ответа от апишки гитхаба при его создании. Есть смысл создать его только с github_id и дальше уже пойти за остальной инфой в джобе, пользователь же сможет продолжать работу с сайтом в это время.

  - Не согласен, тут всего один запрос и он достаточно быстрый.
  - Сделал асинхронно...
  - В итого теперь нужно ждать и обновлять страницу, ситуацию исправил бы какой-нибудь ajax.
  
* Ещё момент - в методах repo_info и repo_list у тебя есть какая-никакая логика, в тестах ты вообще всё это пропускаешь мимо, и стабишь сразу их результат. Правильнее стабить работу Octokit::Client, а не всего GithubHelper

  - Сделал

* Потому что не стоит в джобу передавать сущность и рассчитывать, что ты найдёшь её там в том же состоянии, в котором отправил, потому что джоба могла встать в очередь и выполниться через час, а сущность давно удалили из БД. Принято передавать айдишник, по нему искать сущность в джобе и дальше что-то с ней делать.

  - Исправлено
  
* Ну и по той же причине джоба должна ожидать ошибку по смене стейта (да и другие ошибки) и уметь что-то делать с этим, хотя бы логировать ошибки

  - Добавил проверки вида 'if check.may_finish?'... и удалил их.
  - "уметь что-то делать с этим, хотя бы логировать ошибки".. А что делает job сейчас? Это собственно и делает: возникает ошибка и она идёт в вывод (в логи).

## 0.7.0 (14.09.2024)

Первый релиз приложения